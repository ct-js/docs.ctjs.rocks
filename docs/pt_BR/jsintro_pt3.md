---
sidebarDepth: 3
---

# Introdu√ß√£o ao JavaScript, parte III: Objetos e Arrays em pronfudidade

## Objetos

Tudo em JavaScript √© um objeto! Exceto para `true`, `false`, simples n√∫meros e strings, `null` e `undefined`. O que isso significa para voc√™? Significa que muitas das coisas √∫teis em JS t√™m ‚ú®*propriedades*‚ú® ‚Äî as coisas que est√°vamos falamos na primeira parte desta introdu√ß√£o ao JavaScript.

Ent√£o, como voc√™ pode criar e armazenar um novo objeto? A sintaxe √© simples: voc√™ cria uma lista de propriedades entre `{` essas chaves `}`, separando cada item por uma v√≠rgula (`,`) e separando os nomes das propriedades e os valores com dois-pontos (`:`). Voc√™ ter visto estruturas assim em algum catmods, como o ct.tween:

```js
var myObject = {
    name: 'The hammer of bug killing',
    description: 'Buy this hammer and you will crush these bugs with ease!',
    damage: 100500,
    price: NaN
};
```

Podemos ler as propriedades dos objetos com um acessador de ponto ‚Äî aquele que provavelmente j√° viu em todos os lugares como em `myObject.name`.

Os objetos s√£o transferidos entre vari√°veis e propriedades por refer√™ncia, portanto, se voc√™ continuar o trecho de c√≥digo anterior e tentar armazenar o mesmo em digamos uma copy, e ent√£o modificar o objeto original, `myObject`, voc√™ notar√° que essa mudan√ßa tamb√©m ser√° refletida para a refer√™ncia que atribu√≠mos para a copy. Porque como explicado anteriormente, os objetos s√£o atribu√≠dos as vari√°veis e propriedades por refer√™ncia, o que significa que o objeto √© o mesmo e apenas est√° sendo compartilhado pelas vari√°veis e propriedades! Veja o exemplo a seguir:

```js
this.weapon = myObject;

// Depois‚Ä¶

console.log(this.weapon.price); // √â um NaN! Isso n√£o √© bom, vamos corrigir isso!
myObject.price = 777; // Note que n√£o estamos usando a refer√™ncia `this.weapon` aqui.
console.log(this.weapon.price); // Ele agora √© 777. Show de Bola!
```

### Objetos aninhados

Voc√™ pode armazenar objetos dentro de outros objetos. Voc√™ pode usar refer√™ncias para outros objetos nas propriedades do seu objeto ou voc√™ pode criar esse objetos diretamente sem a necessidade de criar uma refer√™ncia:

```js
this.weapon = {
    name: 'The hammer of bug killing',
    description: 'Buy this hammer and you will crush these bugs with ease!',
    damage: 100500,
    price: 777
};
this.helmet = {
    name: 'The helmet of system thinking',
    description: 'Allows you to get a whole picture',
    wit: 5,
    price: 100
};
this.gear = {
    hands: this.weapon,
    head: this.helmet,
    body: { // Aqui estamos criando um objeto diretamente sem usar uma refer√™ncia!
        name: 'The chestplate of ignorance',
        description: 'Protects your mind from the outer world',
        wit: -100,
        mood: 5,
        price: 3
    }
};

console.log(this.gear.body.name); // Retornar√° a string 'The chestplate of ignorance'.
```

### Deletando as propriedades dos objetos completamente

Voc√™ pode escrever `this.enemy = undefined` e em muitos casos isso ser√° o suficiente, mas se estiver [trabalhando com o armazenamento local](localstorage.html) ou outra forma de dados persistentes, ou ainda, se voc√™ fizer um loop sobre as propriedades de um objeto, voc√™ provavelmente precisar√° remover essa propriedade sem deixar rastros ‚Äî caso ela ainda estar√° l√°, mesmo que n√£o tenha nenhum valor atribu√≠do.

Voc√™ pode usar a palavra reservada `delete` para remover qualquer propriedade de um objeto:

```js
if (!ct.templates.isValid(this.enemy)) {
    delete this.enemy;
}
```

### Se strings e n√∫meros s√£o constantes, ent√£o por que podemos usar m√©todos neles?

Porque o JavaScript √© esperto! Na verdade, existem objetos baseados em strings e n√∫meros simples, e voc√™ pode cri√°-los com `new String('Divine sausage')`, `new Number(42)`, e at√© `new Boolean(true)`. Mas essas formas n√£o s√£o recomendadas, porque 99.99% das vezes voc√™ n√£o precisa dessa funcionalidade. Mesmo ela sendo uma funcionalidade *bastante divertida*, a mesma est√° al√©m do escopo dessa p√°gina de introdu√ß√£o.

O que voc√™ *precisa* √© de todos os m√©todos que `Number` e `String` possuem; para formatar esses valores e manipular as strings. JavaScript fornece isso pra gente quando voc√™ escreve `'  oh no '.trim()` ou `(99.9).toFixed(2)`.

## Arrays

Arrays podem ser pensados como objetos com propriedades num√©ricas e ordenadas, com uma *tonelada* de fun√ß√µes auxiliares.
Declarar um array √© diferente de declarar um objeto:

```js
var groceryList = ['potato', 'carrot', 'thyme'];
this.waveEnemyAmount = [10, 10, 15, 15, 20, 25];

console.log(groceryList[0]); // sair√° no console 'potato'
console.log(groceryList[1]); // sair√° no console 'carrot'
console.log(this.waveEnemyAmount); // ser√° impresso todo o array no console
```

Note como os elementos do array s√£o acessados: usamos um n√∫mero entre colchetes, come√ßando com `[0]` para obter o valor.

Voc√™ pode armazenar objetos complexos em arrays tamb√©m:

```js
this.shopItems = [{
    name: 'The hammer of bug killing',
    description: 'Buy this hammer and you will crush these bugs with ease!',
    damage: 100500,
    price: 777
}, {
    name: 'The helmet of system thinking',
    description: 'Allows you to get a whole picture',
    wit: 5,
    price: 100
}, {
    name: 'The chestplate of ignorance',
    description: 'Protects your mind from the outer world',
    wit: -100,
    mood: 5,
    price: 3
}];

console.log(this.shopItems[0].name); // Sair√° no console 'The hammer of bug killing'
console.log(this.shopItems[2].price); // sair√° no console `3`, o pre√ßo de "The chestplate of ignorance"
```

Aqui acessamos todo o objeto com `[0]`, `[1]`, `[2]` e etc, e ent√£o lemos as propriedades desse objeto anexando `.name` e `.price`. Tenha cuidado com essa sintaxe!

### Obtendo o tamanho do array

Os Arrays t√™m v√°rias fun√ß√µes para agilizar o processamento de qualquer dado de jogo que voc√™ precise.

Primeiro, existe a propriedade `length`, a qual retorna o n√∫mero de elementos do array.

Como podemos us√°-la? Digamos que voc√™ queira limitar a quantidade de lixo no invet√°rio do seu jogador:

```js
this.inventory = ['sword', 'sword', 'sword', 'sword', 'sword', 'sword', 'sword', 'sword', 'sword', 'apple'];
this.maxInventorySize = 10;
// depois‚Ä¶

if (this.inventory.length >= this.maxInventorySize) {
    return; // aborta a fun√ß√£o ou evento atual
}
this.inventory.push('gold ingot'); // Adiciona um novo elemento
```

√â uma pena que eles nunca receber√£o esse "gold ingot" (lingote de ouro ou barra de ouro).

### Adicionando novos elementos ao arrays

Existem tr√™s forma de adicionar elementos ao array:

```js
var pizza = ['tomato sauce'];

pizza.push('pepperoni'); // Essa adiciona um novo elemento no final do array
pizza.unshift('dough'); // Essa adicona o elemento no in√≠cio do array
pizza.splice(2, 0, 'cheese'); // Essa adiciona o elemento depois de pizza[2]. Por enquanto ignore o par√¢metro "0".

console.log(pizza); // A sa√≠da ser√° um array dough, tomato sauce, cheese, e pepperoni. Hum üçï
```

### Removendo elementos do array

Vamos devorar a nossa pizza!

```js
var pizza = ['dough', 'tomato sauce', 'cheese', 'pepperoni'];

pizza.pop('dough'); // Remove o √∫ltimo elemento do array
pizza.splice(1, 2); // Remove dois elementos, come√ßando com pizza[1].
pizza.splice(0, 1, 'crust'); // Remove um elemento, come√ßando com pizza[0] e substitui o mesmo por 'crust'.
pizza.shift(); // Remove o primeiro elemento do array

console.log(pizza); // A sa√≠da ser√° um array vazio!
```

:::tip Mais de uma forma de array.splice
Voc√™ viu que `pizza.splice` foi usado de tr√™s forma diferentes: para adicionar, remover e substituir valores. Como esse m√©todo funciona?

O objetivo dele √© o de modificar um array atrav√©s da adi√ß√£o, substitui√ß√£o ou remo√ß√£o de elementos. A sua forma completa √© `.splice(startFromIndex, deleteCount, addOne, addTwo, addThree, ‚Ä¶)`. Voc√™ pode remover v√°rios elementos do array sem precisar adicionar ou voc√™ pode fazer o contr√°rio, adicionar elementos sem remover:

* Quando voc√™ escreve `.splice(3, 0, 'sausage')`, voc√™ adiciona elementos sem remover, nesse exemplo, um novo elemento depois do terceiro elemento ser√° adicionado.
* Quando voc√™ escreve `.splice(3, 1)`, voc√™ remove apenas um elemento, nesse exemplo, o elemento na posi√ß√£o `3`.
* Quando voc√™ escreve `.splice(3, 1, 'sausage')`, voc√™ substitui um elemento por outro, nesse exemplo, o elemento da posi√ß√£o `3` √© substitu√≠do por `sausage`.
* Quando voc√™ escreve `.splice(3, 2)` voc√™ remove v√°rios elementos de uma vez, nesse exemplo, os elementos da posi√ß√£o `3` e `4`.
:::

### Fun√ß√µes para pesquisar, filtra, ordenar e reduzir arrays

#### Filtrando com `array.filter`

`array.filter` √© uma fun√ß√£o √∫til que cria um novo array a partir do existente. Voc√™ passa uma fun√ß√£o que far√° o filtro como par√¢metro, esse par√¢metro √© o que chamamos de "predicado", que √© escrito por voc√™.

Vamos pegar todas as feras neutras e amig√°veis em nosso besti√°rio:

```js
var bestiary = [{
    name: 'Pig',
    aggressiveness: 'neutral'
}, {
    name: 'Cat',
    aggressiveness: 'friendly'
}, {
    name: 'Wolf',
    aggressiveness: 'hostile'
}, {
    name: 'Bear',
    aggressiveness: 'hostile'
}, {
    name: 'Magic pony',
    aggressiveness: 'neutral'
}];

var neutralAnimals = bestiary.filter(beast => {
    if (beast.aggressiveness === 'hostile') {
        return false;
    }
    return true; // Ser√° executada apenas se a instru√ß√£o anterior n√£o for,
                 // porque `return` para a execu√ß√£o da fun√ß√£o.
});
console.log(neutralAnimals);
```

Cada fera que retorna `false` n√£o ser√° inclu√≠da no array `neutralAnimals`. Assim, aquelas que retornarem `true` ser√£o.

Vamos ver um novo exemplo: obtendo a lista de armas que um h√©roi pode comprar atualmente:

```js
this.money = 1230;
var shop = [{
    name: 'The Art of the Realm of Constants',
    price: 130,
    type: 'book'
}, {
    name: 'The hammer of bug killing',
    price: 100500,
    type: 'weapon'
}, {
    name: 'A rusty axe of intoxication',
    price: 853,
    type: 'weapon'
}, {
    name: 'A scroll of lightning',
    price: 167,
    type: 'book'
}];
// pulando tanto `return` como as chaves ‚Äî essa √© uma sintaxe curta, o resultado ser√° retornado automaticamente!
var purchaseable = shop.filter(item => item.price <= this.money);
var purchaseableWeapon = purchaseable.filter(item => item.type === 'weapon');
console.log(purchaseableWeapon);
```

:::tip Dica
Para saber mais sobre a sintaxe curta, voc√™ pode acessar a documenta√ß√£o que aborda o conceito de arrow functions [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
:::

#### O m√©todo `sort` do array

O m√©todo `array.sort` pode ser utilizado do jeito que est√°, pois ele nos oferece uma ordena√ß√£o natural, tanto para n√∫meros como para strings:

```js
var groceryList = [
    'potato',
    'carrot',
    'salad',
    'sausages'
];
groceryList.sort();
console.log(groceryList); // potato e carrots ser√£o trocados
```

Voc√™ pode notar que diferente dos outros m√©todos semelhantes, a ordena√ß√£o n√£o cria uma novo array, em vez disso, ele modifica o array existente.

Voc√™ pode tamb√©m pode fazer uma ordena√ß√£o n√£o natural, passando um predicado que retornar√° como os objetos ser√£o comparados entre si. Vamos usar a lista da loja acima e ordenar os elementos pelo pre√ßo de forma crescente:

```js
var shop = [{
    name: 'The Art of the Realm of Constants',
    price: 130,
    type: 'book'
}, {
    name: 'The hammer of bug killing',
    price: 100500,
    type: 'weapon'
}, {
    name: 'A rusty axe of intoxication',
    price: 853,
    type: 'weapon'
}, {
    name: 'A scroll of lightning',
    price: 167,
    type: 'book'
}];

shop.sort((a, b) => {
    return a.price - b.price;
});
```

Aqui pegamos dois itens e retornamos a difren√ßa entre eles, o primeiro √© o (`a`) e o segundo √© o (`b`). Se o resultado dessa diferen√ßa √© um n√∫mero negativo, ent√£o o primeiro elemento est√° antes do segundo na ordena√ß√£o, agora se o resultado for um n√∫mero positivo, ent√£o isso significa que o primeiro elemento √© depois do segundo na ordena√ß√£o, mas se o valor resultante for zero, ent√£o eles est√£o no mesmo n√≠vel e pouco importante quem vem antes ou depois.

:::tip Dica
Voc√™ precisa chamar o m√©todo `sort` apenas uma vez por ordena√ß√£o ‚Äî j√° que o JavaScript continuar√° a ordena√ß√£o at√© que o array esteja est√°vel. Mas note que se voc√™ alterar o array adicionando um elemento n√£o ordenado, voc√™ ter√° que chamar o `sort` novamente. Para saber mais sobre o m√©todo `sort`, acesse a documenta√ß√£o dele [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).
:::

#### M√©todos para encontrar e testar elementos do array

Existem muitas formas de encontrar um elemento em um array!

##### Determinando se um elemento est√° dentro do array com `array.includes`

`array.includes(value)` √© uma verifica√ß√£o muito simples quando voc√™ precisa apenas saber se um elemento est√° presente no array atual. Ele retorna um valor booleano, (`true` or `false`).

```js
var buffs = ['vigor', 'rested', 'rage'];
// Adiciona um novo elemento ao array apenas se o mesmo n√£o estiver presente
if (!buffs.includes('blessed')) {
    buffs.push('blessed');
}
```

:::tip Dica
Para saber mais sobre o m√©todo `includes`, veja a documenta√ß√£o dele [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/includes).
:::

##### Verificando se algum elemento no array satisfaz uma condi√ß√£o com `array.some`

Essa fun√ß√£o testa se pelo menos um dos elementos satisfaz a sua condi√ß√£o. Ela aceita um predicado que ser√° testado sobre cada elemento e retornar√° `true` apenas se pelo menos um deles passar no teste do predicado retornando `true`.

```js
this.gear = [{
    name: 'The hammer of bug killing',
    description: 'Buy this hammer and you will crush these bugs with ease!',
    damage: 100500,
    enchantment: 'blessed'
}, {
    name: 'The helmet of system thinking',
    description: 'Allows you to get a whole picture',
    wit: 5,
    enchantment: 'none'
}, {
    name: 'The chestplate of ignorance',
    description: 'Protects your mind from the outer world',
    wit: -100,
    mood: 5,
    enchantment: 'cursed'
}];

// Adiciona em debuff apenas se um dos elementos √© cursed
if (this.gear.some(item => item.enchantment === 'cursed')) {
    this.debuffs.push('cursed');
}
```

:::tip Dica
Para saber mais sobre o m√©todo `some`, acesse a sua documenta√ß√£o [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/some).
:::

#### Obtenha um elemento que satisfa√ßa uma condi√ß√£o com os m√©todos `array.find`, `array.findIndex`

Elas s√£o semelhantes ao m√©todo `array.some`, mas diferente de `array.some` que retorna um valor booleano, array.find retornar√° o primeiro elemento que satisfizer a condi√ß√£o passada pelo predicado, em caso de falha, ser√° retornado `undefined`, j√° `array.findIndex` retornar√° a posi√ß√£o do elemento que satisfizer a condi√ß√£o definida pelo predicado, caso n√£o seja satisfeita, ent√£o `-1` ser√° restornando, indicando que nenhum elemento foi encotrado.

```js
this.gear = [{
    name: 'The hammer of bug killing',
    type: 'weapon'
}, {
    name: 'The helmet of system thinking',
    type: 'head'
}, {
    name: 'The chestplate of ignorance',
    type: 'torso'
}];
// Procura no array gear pelo objeto em que o valor da sua propriedade type seja igual a string "weapon" e guarda esse objeto na vari√°vel weapon.
var weapon = this.gear.find(item => item.type === 'weapon');
this.damage = weapon.damage;

// Remove ohelmet
var helmetIndex = this.gear.findIndex(item => item.type === 'head');
if (helmetIndex !== -1) { // Temos que ter certeza que encontramos um helmet
    this.gear.splice(helmetIndex, 1);
}
```

:::tip Dica
Para maiores informa√ß√µes sobre os m√©todos `find` e `findIndex`, voc√™ pode consultar a document√ß√£o deles [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/find) e [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex), respectivamente.
:::

##### Encontre a posi√ß√£o de um elemento conhecido em um array com `array.indexOf`

Semelhante ao `array.findIndex`, `array.indexOf` retornar√° a posi√ß√£o do elemento especificado em um array. √â √∫til quando voc√™ armazena n√∫meros ou string em um array, ou se voc√™ tem uma refer√™ncia do objeto que voc√™ procura.

```js
var groceryList = [
    'potato',
    'carrot',
    'cucumber',
    'banana',
    'cherry'
];
var carrotIndex = array.indexOf('carrot');
if (carrotIndex !== -1) { // Temos que ter a certeza que encontramos um item
    groceryList.splice(carrotIndex, 1);
}
```
:::tip Dica
A documenta√ß√£o para `indexOf` pode ser consultada [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf).
:::

#### M√©todo `reduce` do array

O m√©todo `array.reduce` percorre cada elemento de um array, executando o seu predicado passado como par√¢metro, e passa o resultado desse predicado para a pr√≥xima chamada. Normalmente ela √© utilizada para rapidamente coletar diferentes estat√≠sticas de um array, e escrevendo diferentes predicados, voc√™ pode calcular diferentes valores estat√≠sticos.

Digamos que voc√™ escreva um jogo de tower defense e que voc√™ tem um chef√£o final na √∫ltima onda. Voc√™ quer calcular o tempo antes que o chef√£o apare√ßa e, para isso, quer somar todos os atrasos das ondas.

Considerando a estrutura a seguir, podemos fazer uso do m√©todo `.reduce` do array para somar todos os atrasos:

```js
var waves = [{
    delay: 30,
    monsters: [{
        template: 'Monster_Flyer',
        health: 10,
        amount: 10
    }]
}, {
    delay: 10,
    monsters: [{
        template: 'Monster_Flyer',
        health: 15,
        amount: 12
    }]
}, {
    delay: 12,
    monsters: [{
        template: 'Monster_Flyer',
        health: 15,
        amount: 20
    }, {
        template: 'Monster_Tank',
        health: 15,
        amount: 20
    }]
}, {
    delay: 20,
    monsters: [{
        template: 'Monster_Boss',
        health: 1000,
        amount: 1
    }]
}];

var timeTillBoss = waves.reduce((currentSum, wave) => {
    return currentSum + wave.delay
}, 0); // O valor 0, zero, representa o valor inicial.
```

Agora vamos usar o mesmo array para obter a quantidade total de inimigos na onda, pelo tipo deles. Este ser√° um exemplo mais dif√≠cil, porque precisamos de um array de monstros dentro do nosso array principal:

```js
var monstersInTheLevel = waves.reduce((currentStats, wave) => {
    for (const monsterGroup of wave.monsters) {
        // Inicializa um grupo de monstros se ele ainda tiver sido feito pelo objeto de estat√≠sticas
        if (!currentStats[monsterGroup.template]) {
            currentStats[monsterGroup.template] = 0;
        }
        currentStats[monsterGroup.template] += monsterGroup.amount;
    }
}, {}); // O valor inicial √© um objeto vazio
```

Foi f√°cil de entender? talvez. Poderia ser feito com os loops regulares? Sem d√∫vida. Entretanto, se voc√™ tiver diferentes arrays que precisam ser processados em, seria dif√≠cil escrever loops para cada um deles. Com `.reduce`, `.forEach`, `.filter`, `.find`, voc√™ guardar o seu predicado em vari√°vel ou propriedade e us√°-la muitas vezes quando necess√°rio, deixando assim, o seu c√≥digo mais limpo.

:::tip Dica
Voc√™ pode consultar a documenta√ß√£o sobre o `reduce` [aqui](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
:::

### JavaScript e o conhecimento relacionado ao lado medonho do array üï∏üï∑

#### Arrays de duas dimens√µes

Em JavaScript, os arrays do jeito que est√° √© apenas de uma dimens√£o: podemos dizer ent√£o que ele √© apenas uma lista. Mas se voc√™ ent√£o criar uma de lista de outra lista, teremos ent√£o um array de duas dimens√µes semelhante aos encontrados em outras lingaugens, como em Java por exemplo!

```js
var myMap = [
    [1, 1, 1, 1, 0],
    [0, 0, 1, 0, 1],
    [2, 0, 1, 1, 1],
    [1, 0, 1, 0, 0],
    [1, 1, 1, 0, 0],
];
```

Voc√™ pode ent√£o obter um com `myMap[2][0]`. (Esse exemplo retornaria `2` ‚Äî o elemento localizado na segunda linha da coluna 0.)

:::tip Dica
Lembre-se que em JavaScript assim como em outras linguagens, a primeira posi√ß√£o do array √© o √≠ndice de n√∫mero `0` (zero). Voc√™ pode aprender mais sobre arrays [aqui](https://developer.mozilla.org/pt-BR/docs/Learn/JavaScript/First_steps/Arrays).
:::

#### Acessador especial no estilo array para as propriedades dos objetos

Voc√™ lembra que quase tudo em JavaScript √© um objeto? E que arrays tamb√©m s√£o? Por que voc√™ acha que os arrays t√™m uma sintaxe especial para acessar os seus elementos?

Porque na verdade isso n√£o √© uma exclusividade dos arrays! Cada objeto pode ter as suas propriedades lidas, exclu√≠das e alteradas com um acessador de prorpiedade no estilo array:

```js
var myObject = {
    name: 'The hammer of bug killing',
    description: 'Buy this hammer and you will crush these bugs with ease!',
    damage: 100500,
    price: NaN
};
myObject['price'] = 1000;
```

Qualquer valor que pode ser convertido para strings pode ser utilizada como um acessador:

```js
// Esse √© um exemplo estranho, mas e se fosse assim a forma que voc√™ apresenta uma barra de habilidades personaliz√°vel em um ARPG?
var abilities = {
    '0': 'Moon strike',
    '1': 'Slashing leap',
    '5': 'Mend'
};
// Reposiciona a habilidade:
var ability = abilities[1];
delete abilities[1];
abilities[2] = ability;
```

E o melhor de tudo, o acessador n√£o precisa ser est√°tico! Voc√™ pode calcular valores concatenando strings ou fazendo outras coisas m√°gicas:

```js
this.stats = {
    resistanceFire: 5,
    resistanceIce: 0
};
this.armor = {
    name: 'The Robe of Chill',
    resistanceType: 'Ice',
    resistanceBoost: 15
};
// `'resistance' + this.armor.resistanceType` √© 'resistanceIce',
// Ent√£o a propriedade this.stats.resistanceIce ser√° alterada.
this.stats['resistance' + this.armor.resistanceType] += this.armor.resistanceBoost;
```

#### Um caso especial: strings s√£o‚Ä¶ arrays?!

As strings t√™m uma prorpiedade `.length`, a qual retorna o tamanho da string, d√£√£√£√£√£. Elas tamb√©m podem retornar os caracteres em uma posi√ß√£o espec√≠fica se voc√™ tentar usar um acessador no estilo array:

```js
var string = 'Hello ct.js!';
console.log(string.length); // Retronar√° 12
console.log(string[1]) // Retornar√° 'e'
```

Mas as strings n√£o t√™m todos esses m√©todos legais e inteligentes como `.forEach`, `.map`, ou `.filter`. Na verdade ela tem os [seus pr√≥prios m√©todos](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#instance_methods) para simplificar a transforma√ß√£o de strings, como `.trim()`, `.search`, `.replace`, [e outros](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#instance_methods), al√©m disso, as strings tamb√©m t√™m o seu pr√≥prio m√©todo `.slice`. N√£o que voc√™ precise tratar as suas strings como arrays reais, mas se voc√™ *realmente* precisar, voc√™ pode usar `Array.from(yourString)` para criar um novo array que tenha os caracteres da string como elementos do array.

## Conclucs√£o

Objetos e arrays s√£o recursos poderosos ‚Äî eles s√£o principalmente uma estrutura em que cabem tudo o que voc√™ coloca neles. Sabendo como manipul√°-los eficientemente, permitir√° que voc√™ escreva c√≥digos de forma r√°pida e f√°cil. Mas n√£o se preocupe se voc√™ n√£o conseguir lembrar tudo agora ‚Äî a perfei√ß√£o vem com a pr√°tica, e a pr√°tica precisa de tempo. N√£o como se eu usasse todos os m√©todos uma vez por m√™s, he-he.

Boa codifica√ß√£o!  
CoMiGo
